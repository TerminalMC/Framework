plugins {
    id("fabric-loom") version("${loom_version}") apply(false)
    id("net.minecraftforge.gradle") version("${forgegradle_version}") apply(false)
    id("org.spongepowered.gradle.vanilla") version("${vanillagradle_version}") apply(false)
    id("org.spongepowered.mixin") version("${mixingradle_version}") apply(false)
    id("com.modrinth.minotaur") version("${minotaur_version}")
    id("net.darkhax.curseforgegradle") version("${curseforgegradle_version}")
    id("com.github.breadmoirai.github-release") version("${githubrelease_version}")
    id("org.ajoberstar.grgit.service") version("${grgitservice_version}")
    id("net.neoforged.licenser") version("${licenser_version}") apply false
}

subprojects {
    version = mod_version
    group = mod_group

    // Publishing
    if (name != "common") {
        apply(plugin: "com.modrinth.minotaur")
        apply(plugin: "net.darkhax.curseforgegradle")
        apply(plugin: "com.github.breadmoirai.github-release")
        apply(plugin: "org.ajoberstar.grgit.service")

        afterEvaluate {
            modrinth {
                token = System.getenv().MODRINTH_TOKEN ? System.getenv().MODRINTH_TOKEN : "empty"
                projectId = modrinth_id
                versionNumber = mod_version
                versionType = release_type
                versionName = "v${mod_version}-${capsLoader(name)}-${minecraft_version}"
                changelog = rootProject.file("changelog.md").text
                uploadFile = name == "fabric" ? remapJar : jar
                loaders = project.property("release_mod_loaders_${name}").split(",") as List
                gameVersions = project.property("release_game_versions_${name}").split(",") as List

                def deps = []
                if (project.hasProperty("release_required_dep_ids_${name}_mr")) {
                    project.property("release_required_dep_ids_${name}_mr").split(",").each { String id ->
                        deps << new com.modrinth.minotaur.dependencies.ModDependency(id, "required")
                    }
                }
                if (project.hasProperty("release_optional_dep_ids_${name}_mr")) {
                    project.property("release_optional_dep_ids_${name}_mr").split(",").each { String id ->
                        deps << new com.modrinth.minotaur.dependencies.ModDependency(id, "optional")
                    }
                }
                if (project.hasProperty("release_incompatible_dep_ids_${name}_mr")) {
                    project.property("release_incompatible_dep_ids_${name}_mr").split(",").each { String id ->
                        deps << new com.modrinth.minotaur.dependencies.ModDependency(id, "incompatible")
                    }
                }
                dependencies = deps
                syncBodyFrom = rootProject.file("README.md").text
            }
            tasks.modrinth.onlyIf { System.getenv().MODRINTH_TOKEN }
            tasks.modrinth.dependsOn(build, tasks.modrinthSyncBody)
            tasks.modrinthSyncBody.onlyIf { System.getenv().MODRINTH_TOKEN }

            task curseforge(type: net.darkhax.curseforgegradle.TaskPublishCurseForge) {
                apiToken = System.getenv().CURSEFORGE_TOKEN ? System.getenv().CURSEFORGE_TOKEN : "empty"

                disableVersionDetection()
                String module = project.name

                def file = upload(curseforge_id, module == "fabric" ? remapJar : jar)
                file.displayName = "v${mod_version}-${capsLoader(module)}-${minecraft_version}"
                file.releaseType = release_type
                file.changelog = rootProject.file("changelog.md").text
                file.changelogType = "markdown"
                project.property("release_mod_loaders_${module}").split(",").each { String id ->
                    file.addModLoader(id)
                }
                project.property("release_game_versions_${module}").split(",").each { String id ->
                    file.addGameVersion(id, module)
                }

                if (project.hasProperty("release_required_dep_ids_${module}_cf")) {
                    project.property("release_required_dep_ids_${module}_cf").split(",").each { String id ->
                        file.addRequirement(id)
                    }
                }
                if (project.hasProperty("release_optional_dep_ids_${module}_cf")) {
                    project.property("release_optional_dep_ids_${module}_cf").split(",").each { String id ->
                        file.addOptional(id)
                    }
                }
                if (project.hasProperty("release_incompatible_dep_ids_${module}_cf")) {
                    project.property("release_incompatible_dep_ids_${module}_cf").split(",").each { String id ->
                        file.addIncompatibility(id)
                    }
                }
            }
            tasks.curseforge.onlyIf { System.getenv().CURSEFORGE_TOKEN }
            tasks.curseforge.dependsOn(build)

            githubRelease {
                token = System.getenv().GITHUB_TOKEN ? System.getenv().GITHUB_TOKEN : "empty"
                owner = github_repo_owner
                repo = github_repo
                tagName = "v${mod_version}"
                prerelease = release_type == "alpha" || release_type == "beta"
                releaseName = "v${mod_version} for ${minecraft_version}"
                body = rootProject.file("changelog.md").text
                targetCommitish = grgitService.service.get().grgit.branch.current().name
                overwrite = false
                allowUploadToExisting = true
                releaseAssets = List.of(name == "fabric" ? remapJar : jar, sourcesJar)
            }
            tasks.githubRelease.onlyIf { System.getenv().GITHUB_TOKEN }
            tasks.githubRelease.dependsOn(build)
        }
    }
}

tasks.register("rebrandProject") {
    def rebrandFile = file("rebrand.properties")
    if (!rebrandFile.exists()) {
        println("'rebrand.properties' file not found.")
        return
    }
    doLast {
        def properties = new Properties()
        rebrandFile.withInputStream { stream ->
            properties.load(stream)
        }

        file(".").eachFileRecurse { file ->
            if (file.isFile() && !file.name.startsWith(".git") && !file.name.startsWith("gradlew")
                    && (file.relativePath(project.rootDir) == ".." || file.path.contains("src\\main"))) {
                try {
                    properties.each { key, value ->
                        if (file.name.contains(key.toString())) {
                            def newName = file.name.replace(key.toString(), value.toString())
                            def newFile = new File(file.parentFile, newName)
                            if (file.renameTo(newFile)) {
                                println("Renamed '${file.name}'")
                            } else {
                                println("Failed to rename '${file.name}'")
                            }
                        }
                    }
                } catch (IOException ex) {
                    println("Error renaming file '${file.path}': ${ex}")
                }
            }
        }

        file(".").eachFileRecurse { file ->
            if (file.isFile() && !file.name.startsWith(".git") && !file.name.startsWith("gradlew")
                    && (file.relativePath(project.rootDir) == ".." || file.path.contains("src\\main"))) {
                try {
                    def content = file.text
                    properties.each { key, value ->
                        content = content.replaceAll(key.toString(), value.toString())
                    }
                    file.withWriter("UTF-8") { writer -> writer.write(content) }
                } catch (IOException ex) {
                    println("Error updating contents of file '${file.path}': ${ex}")
                }
            }
        }
    }
}

static String capsLoader(String loader) {
    switch(loader) {
        case "fabric": return "Fabric"
        case "quilt": return "Quilt"
        case "forge": return "Forge"
        case "neoforge": return "NeoForge"
        default: return loader
    }
}
